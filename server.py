from pathlib import Path
import subprocess
import xml.etree.ElementTree as ET
from datetime import datetime

from mcp.server.fastmcp import FastMCP  # from mcp[cli]

BASE_DIR = Path(__file__).resolve().parent
CODEBASE_DIR = BASE_DIR / "codebase"

mcp = FastMCP("SE333-TestAgent")


def _run(cmd, cwd):
    result = subprocess.run(
        cmd,
        cwd=cwd,
        text=True,
        capture_output=True,
    )
    return {
        "cmd": " ".join(cmd),
        "returncode": result.returncode,
        "stdout": result.stdout,
        "stderr": result.stderr,
    }


@mcp.tool()
def run_mvn_tests(goals: str = "clean test jacoco:report") -> dict:
    """Run Maven tests (and JaCoCo) on the codebase."""
    if not CODEBASE_DIR.exists():
        return {"error": f"codebase directory not found: {CODEBASE_DIR}"}
    cmd = ["mvn"] + goals.split()
    return _run(cmd, cwd=CODEBASE_DIR)


@mcp.tool()
def read_coverage() -> dict:
    """Return overall coverage + low-coverage classes from JaCoCo."""
    report = CODEBASE_DIR / "target" / "site" / "jacoco" / "jacoco.xml"
    if not report.exists():
        return {"error": f"JaCoCo report not found at {report}. Run run_mvn_tests first."}

    root = ET.parse(report).getroot()

    total_missed = 0
    total_covered = 0
    for c in root.findall(".//counter[@type='INSTRUCTION']"):
        total_missed += int(c.attrib.get("missed", 0))
        total_covered += int(c.attrib.get("covered", 0))
    overall = 0.0 if total_missed + total_covered == 0 else 100.0 * total_covered / (total_missed + total_covered)

    gaps = []
    for cls in root.findall(".//class"):
        c = cls.find("counter[@type='INSTRUCTION']")
        if c is None:
            continue
        missed = int(c.attrib.get("missed", 0))
        covered = int(c.attrib.get("covered", 0))
        total = missed + covered
        pct = 0.0 if total == 0 else 100.0 * covered / total
        if pct < 80.0:
            gaps.append({"name": cls.attrib.get("name"), "coverage": round(pct, 2)})

    return {
        "overall_instruction_coverage": round(overall, 2),
        "low_coverage_classes": sorted(gaps, key=lambda g: g["coverage"])[:20],
    }


@mcp.tool()
def generate_test_skeleton(fqcn: str) -> dict:
    """Create/append a JUnit test skeleton for a fully-qualified class."""
    parts = fqcn.split(".")
    if len(parts) < 2:
        return {"error": "Use fully-qualified name like 'org.example.MyClass'."}

    class_name = parts[-1]
    package_path = Path(*parts[:-1])

    main_file = CODEBASE_DIR / "src" / "main" / "java" / package_path / f"{class_name}.java"
    if not main_file.exists():
        return {"error": f"Main class not found at {main_file}"}

    test_dir = CODEBASE_DIR / "src" / "test" / "java" / package_path
    test_dir.mkdir(parents=True, exist_ok=True)
    test_file = test_dir / f"{class_name}AgentTest.java"

    if test_file.exists():
        with test_file.open("a", encoding="utf-8") as f:
            f.write("\n// TODO: add more edge-case tests generated by MCP agent\n")
        status = "updated"
    else:
        package_line = f"package {'.'.join(parts[:-1])};"
        content = f"""{package_line}

import org.junit.Test;
import static org.junit.Assert.*;

public class {class_name}AgentTest {{

    // Auto-generated by MCP testing agent on {datetime.utcnow().isoformat()}Z

    @Test
    public void basicBehavior_shouldNotThrow() {{
        // TODO: add real assertions using {class_name}
        assertTrue(true);
    }}
}}
"""
        with test_file.open("w", encoding="utf-8") as f:
            f.write(content)
        status = "created"

    return {"status": status, "test_file": str(test_file.relative_to(BASE_DIR))}


@mcp.tool()
def git_status() -> str:
    return _run(["git", "status", "-sb"], cwd=BASE_DIR)["stdout"]


@mcp.tool()
def git_add_all() -> str:
    out = _run(["git", "add", "-A"], cwd=BASE_DIR)
    return out["stdout"] or out["stderr"] or "Staged all changes."


@mcp.tool()
def git_commit(message: str) -> str:
    return _run(["git", "commit", "-m", message], cwd=BASE_DIR)["stdout"]


@mcp.tool()
def git_push(remote: str = "origin") -> str:
    return _run(["git", "push", remote, "HEAD"], cwd=BASE_DIR)["stdout"]


@mcp.tool()
def git_pull_request(base: str = "main", title: str = "SE333 MCP Agent PR", body: str = "") -> str:
    """Return a PR-style description (no real network calls)."""
    if not body:
        body = "Automated PR description from SE333 MCP testing agent."
    return f"# {title}\n\nBase: `{base}`\n\n{body}\n"


@mcp.tool()
def suggest_boundary_tests(param_name: str, min_value: int, max_value: int) -> str:
    vals = [min_value - 1, min_value, min_value + 1,
            max_value - 1, max_value, max_value + 1]
    return f"Suggested boundary test values for {param_name}: " + ", ".join(str(v) for v in vals)


@mcp.tool()
def review_class(fqcn: str) -> str:
    parts = fqcn.split(".")
    class_name = parts[-1]
    package_path = Path(*parts[:-1])
    main_file = CODEBASE_DIR / "src" / "main" / "java" / package_path / f"{class_name}.java"
    if not main_file.exists():
        return f"Main class not found: {main_file}"

    text = main_file.read_text(encoding="utf-8", errors="ignore")
    lines = text.splitlines()
    issues = []
    if len(lines) > 400:
        issues.append(f"- Large file ({len(lines)} lines); consider refactoring.")
    if "TODO" in text:
        issues.append("- Contains TODOs; ensure they are resolved or documented.")
    if "System.out.println" in text:
        issues.append("- Uses System.out.println; prefer a logger.")

    if not issues:
        return f"No simple issues detected in {fqcn}."
    return "Quick review for " + fqcn + ":\n" + "\n".join(issues)


if __name__ == "__main__":
    mcp.run(transport="sse")
